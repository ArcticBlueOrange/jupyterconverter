{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7wpiobj1-lkcr-087f-e3l5-8qnjtodepr7w",
   "metadata": {},
   "outputs": [],
   "source": [
    "{\n",
    " \"cells\": [\n",
    "  {\n",
    "   \"cell_type\": \"markdown\",\n",
    "   \"execution_count\": null,\n",
    "   \"id\": \"s881u7s3-cr46-wt0w-3crl-bti6cps85bdm\",\n",
    "   \"metadata\": {},\n",
    "   \"outputs\": [],\n",
    "   \"source\": [\n",
    "    \"## P2J - Python 2 Jupyter utility script\\n\",\n",
    "    \"\",\n",
    "    \"#\",\n",
    "    \"\",\n",
    "    \"run this script to convert easily and reversably scripts and notebooks, while keeping the formatted cells, comments and outputs\"\n",
    "   ]\n",
    "  },\n",
    "  {\n",
    "   \"cell_type\": \"code\",\n",
    "   \"execution_count\": \"1\",\n",
    "   \"id\": \"j5as43ab-qdcp-5jix-c043-svdjs5mlc7rw\",\n",
    "   \"metadata\": {},\n",
    "   \"outputs\": [],\n",
    "   \"source\": [\n",
    "    \"import os\\n\",\n",
    "    \"import sys\\n\",\n",
    "    \"import re\\n\",\n",
    "    \"import datetime as dt\\n\",\n",
    "    \"import random as rnd\\n\",\n",
    "    \"import json\\n\",\n",
    "    \"from pprint import pprint\\n\",\n",
    "    \"from copy import deepcopy\\n\",\n",
    "    \"from operator import xor\\n\",\n",
    "    \"from pathlib import Path\\n\",\n",
    "    \"from types import SimpleNamespace\\n\",\n",
    "    \"\\n\",\n",
    "    \"TITLE = r\\\"\\\"\\\"\\n\",\n",
    "    \"______  ___ \\n\",\n",
    "    \"| ___ \\\\|_  |\\n\",\n",
    "    \"| |_/ /  | |\\n\",\n",
    "    \"|  __/2  | |\\n\",\n",
    "    \"| |  /\\\\__/ /\\n\",\n",
    "    \"\\\\_|  \\\\____/ \\n\",\n",
    "    \"\\\"\\\"\\\"\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"class reg():\\n\",\n",
    "    \"    blank = r\\\"^\\\\s*$\\\"\\n\",\n",
    "    \"    code_separator = r\\\"^# In\\\\[([\\\\d\\\\s]*)\\\\]:?.*\\\"\\n\",\n",
    "    \"    markdown = r\\\"# (#.*\\\\n)\\\"\\n\",\n",
    "    \"    scriptrow = r\\\"^(\\\\s*)(.+)$\\\"\\n\",\n",
    "    \"    start = r\\\"(#.*!\\\\/usr\\\\/.*)|# coding.*|^$\\\"\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"OPTIONS = {\\n\",\n",
    "    \"    'noisy': True,\\n\",\n",
    "    \"    'j2p': {\\n\",\n",
    "    \"        # TODO implement options for j2py\\n\",\n",
    "    \"        # 'keep_outputs': False, #NA\\n\",\n",
    "    \"        # 'separate_markdown': True, #NA\\n\",\n",
    "    \"        # 'keep_separators':True ,#NA\\n\",\n",
    "    \"    },\\n\",\n",
    "    \"    'p2j': {\\n\",\n",
    "    \"        'blank_separators': False,  # use blank rows to separate cells\\n\",\n",
    "    \"        'in_separators': True,  # use In[ ] to separate code\\n\",\n",
    "    \"        'markdown_separators': True,  # use # #text to separate markdown\\n\",\n",
    "    \"    }\\n\",\n",
    "    \"}\\n\",\n",
    "    \"\\n\",\n",
    "    \"script_cell_template = {\\n\",\n",
    "    \"    \\\"cell_type\\\": \\\"\\\",  # code, markdown or raw\\n\",\n",
    "    \"    \\\"execution_count\\\": None,\\n\",\n",
    "    \"    \\\"id\\\": \\\"\\\",\\n\",\n",
    "    \"    \\\"metadata\\\": {},\\n\",\n",
    "    \"    \\\"outputs\\\": [],\\n\",\n",
    "    \"    \\\"source\\\": []\\n\",\n",
    "    \"}\\n\",\n",
    "    \"\\n\",\n",
    "    \"notebook_info = {\\n\",\n",
    "    \"    \\\"metadata\\\": {\\n\",\n",
    "    \"        \\\"kernelspec\\\": {\\n\",\n",
    "    \"            \\\"display_name\\\": \\\"Python 3 (ipykernel)\\\",\\n\",\n",
    "    \"            \\\"language\\\": \\\"python\\\",\\n\",\n",
    "    \"            \\\"name\\\": \\\"python3\\\"\\n\",\n",
    "    \"        },\\n\",\n",
    "    \"        \\\"language_info\\\": {\\n\",\n",
    "    \"            \\\"codemirror_mode\\\": {\\n\",\n",
    "    \"                \\\"name\\\": \\\"ipython\\\",\\n\",\n",
    "    \"                \\\"version\\\": sys.version_info.major\\n\",\n",
    "    \"            },\\n\",\n",
    "    \"            \\\"file_extension\\\": \\\".py\\\",\\n\",\n",
    "    \"            \\\"mimetype\\\": \\\"text/x-python\\\",\\n\",\n",
    "    \"            \\\"name\\\": \\\"python\\\",\\n\",\n",
    "    \"            \\\"nbconvert_exporter\\\": \\\"python\\\",\\n\",\n",
    "    \"            \\\"pygments_lexer\\\": \\\"ipython3\\\",\\n\",\n",
    "    \"            \\\"version\\\": f\\\"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\\\",\\n\",\n",
    "    \"        }\\n\",\n",
    "    \"    },\\n\",\n",
    "    \"    \\\"nbformat\\\": 4,\\n\",\n",
    "    \"    \\\"nbformat_minor\\\": 5\\n\",\n",
    "    \"}\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def gen_id(chars: str = \\\"abcdefghijklmnopqrstuvwxyz0123456789\\\",\\n\",\n",
    "    \"           lens: list = [8, 4, 4, 4, 12],\\n\",\n",
    "    \"           sep: str = \\\"-\\\"):\\n\",\n",
    "    \"    return sep.join(\\\"\\\".join(rnd.choice(chars) for i in range(l)) for l in lens)\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def convert_name(s):\\n\",\n",
    "    \"    if '.ipynb' in s:\\n\",\n",
    "    \"        return s.replace('.ipynb', '.py')\\n\",\n",
    "    \"    elif '.py' in s:\\n\",\n",
    "    \"        return s.replace('.py', '.ipynb')\\n\",\n",
    "    \"    elif s == 'demo':\\n\",\n",
    "    \"        return s\\n\",\n",
    "    \"    else:\\n\",\n",
    "    \"        raise BaseException(\\n\",\n",
    "    \"            f\\\"{s} not recognized among the possible parameters - py or ipynb\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def p(*args, noise=2, **kwargs):\\n\",\n",
    "    \"    if OPTIONS['noisy']:\\n\",\n",
    "    \"        print(*args, **kwargs)\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"# windowselect()\\n\"\n",
    "   ]\n",
    "  },\n",
    "  {\n",
    "   \"cell_type\": \"code\",\n",
    "   \"execution_count\": \"3\",\n",
    "   \"id\": \"6j4wtshi-4poy-303q-4eao-cnr3fjch1ybl\",\n",
    "   \"metadata\": {},\n",
    "   \"outputs\": [],\n",
    "   \"source\": [\n",
    "    \"def py2j(dir_input: str, dir_output: str):\\n\",\n",
    "    \"    print(dir_input, '->', dir_output)\\n\",\n",
    "    \"    with open(dir_input) as py:\\n\",\n",
    "    \"        rows = py.readlines()\\n\",\n",
    "    \"        iterrows = iter(rows)\\n\",\n",
    "    \"        # print(rows)\\n\",\n",
    "    \"\\n\",\n",
    "    \"    split_cells = []\\n\",\n",
    "    \"    cur = deepcopy(script_cell_template)  # cur is a single Jupyter cell\\n\",\n",
    "    \"    cur['id'] = gen_id()\\n\",\n",
    "    \"    cur['cell_type'] = 'code'\\n\",\n",
    "    \"    cur['source'] = []\\n\",\n",
    "    \"    start = True\\n\",\n",
    "    \"    for row in iterrows:\\n\",\n",
    "    \"        # if a cell at the beginning contains only comments, transform it into a markdown cell\\n\",\n",
    "    \"        # ignore all beginning rows containing shebangs (for now, TODO improve using the info for the script itself?)\\n\",\n",
    "    \"        if start:\\n\",\n",
    "    \"            if re.match(reg.start, row):\\n\",\n",
    "    \"                continue\\n\",\n",
    "    \"            else:\\n\",\n",
    "    \"                start = False\\n\",\n",
    "    \"        # check if the rows contain the console separator '# In[int]:', or a markdown title separator '# #something'\\n\",\n",
    "    \"        space_sep = re.match(reg.blank, row)\\n\",\n",
    "    \"        # when a blank space is encountered, iterate next cells and evaluate whether the next one is a valid py script\\n\",\n",
    "    \"        if space_sep and OPTIONS['p2j']['blank_separators']:\\n\",\n",
    "    \"            temp = ['\\\\n']\\n\",\n",
    "    \"            for temprow in iterrows:\\n\",\n",
    "    \"                if re.match(reg.blank, temprow):\\n\",\n",
    "    \"                    temp.append(temprow)\\n\",\n",
    "    \"                else:\\n\",\n",
    "    \"                    # TODO duplicate match definition. not soo good\\n\",\n",
    "    \"                    rowmatch = re.match(reg.scriptrow, temprow).groups()\\n\",\n",
    "    \"                    if rowmatch[0] == '':\\n\",\n",
    "    \"                        # all the past rows are just useless blank\\n\",\n",
    "    \"                        # a new cell is created here\\n\",\n",
    "    \"                        if cur['source']:\\n\",\n",
    "    \"                            split_cells.append(cur)\\n\",\n",
    "    \"                        cur = deepcopy(script_cell_template)\\n\",\n",
    "    \"                        cur['id'] = gen_id()\\n\",\n",
    "    \"                        cur['cell_type'] = 'code'\\n\",\n",
    "    \"                        # p(f'BLANK ROWS DELETION!')\\n\",\n",
    "    \"                    else:\\n\",\n",
    "    \"                        # this row and the previous ones are part of a function\\n\",\n",
    "    \"                        # better not break them\\n\",\n",
    "    \"                        ...\\n\",\n",
    "    \"                        # p(f'BLANK ROWS SAVED! {rowmatch[1:]}')\\n\",\n",
    "    \"\\n\",\n",
    "    \"                    cur['source'].extend(temp)\\n\",\n",
    "    \"                    break\\n\",\n",
    "    \"            row = temprow\\n\",\n",
    "    \"            # p(temprow)\\n\",\n",
    "    \"\\n\",\n",
    "    \"        cell_sep = re.match(reg.code_separator, row)\\n\",\n",
    "    \"        mkdn_sep = re.match(reg.markdown, row)\\n\",\n",
    "    \"        # when a cell separator is hit, split_cells gets updated and a new cell is generated\\n\",\n",
    "    \"        if cell_sep and OPTIONS['p2j']['in_separators']:\\n\",\n",
    "    \"            if cur['source']:\\n\",\n",
    "    \"                split_cells.append(cur)\\n\",\n",
    "    \"            cur = deepcopy(script_cell_template)\\n\",\n",
    "    \"            cur['id'] = gen_id()\\n\",\n",
    "    \"            cur['cell_type'] = 'code'\\n\",\n",
    "    \"            cur['execution_count'] = cell_sep[1] if cell_sep[1] != ' ' else None\\n\",\n",
    "    \"            continue\\n\",\n",
    "    \"        # when a markdown separator is hit, a new cell is generated only if the current one isn't already a md cell\\n\",\n",
    "    \"        elif mkdn_sep and cur['cell_type'] != 'markdown' and OPTIONS['p2j']['markdown_separators']:\\n\",\n",
    "    \"            if cur['source']:\\n\",\n",
    "    \"                split_cells.append(cur)\\n\",\n",
    "    \"            cur = deepcopy(script_cell_template)\\n\",\n",
    "    \"            cur['id'] = gen_id()\\n\",\n",
    "    \"            cur['cell_type'] = 'markdown'\\n\",\n",
    "    \"            cur['source'].append(mkdn_sep[1])\\n\",\n",
    "    \"            # p(repr(mkdn_sep[1]), repr(mkdn_sep), repr(row))\\n\",\n",
    "    \"        else:\\n\",\n",
    "    \"            if cur['cell_type'] != 'markdown':\\n\",\n",
    "    \"                cur['source'].append(row)\\n\",\n",
    "    \"            else:\\n\",\n",
    "    \"                try:\\n\",\n",
    "    \"                    cur['source'].append(re.match(r\\\"# (.*)\\\", row)[1])\\n\",\n",
    "    \"                except:\\n\",\n",
    "    \"                    cur['source'].append(row)\\n\",\n",
    "    \"            # p('--added', repr(row), end='\\\\n')\\n\",\n",
    "    \"    else:\\n\",\n",
    "    \"        split_cells.append(cur)\\n\",\n",
    "    \"\\n\",\n",
    "    \"    # final json output\\n\",\n",
    "    \"    json_output = {\\n\",\n",
    "    \"        \\\"cells\\\": split_cells,\\n\",\n",
    "    \"        **notebook_info\\n\",\n",
    "    \"    }\\n\",\n",
    "    \"\\n\",\n",
    "    \"    with open(dir_output, 'w') as out_file:\\n\",\n",
    "    \"        out_file.write(json.dumps(json_output, indent=True))\\n\",\n",
    "    \"        p(f\\\"saved to file {dir_output}\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def j2py(dir_input: str, dir_output: str):\\n\",\n",
    "    \"    print(dir_input, '->', dir_output)\\n\",\n",
    "    \"    with open(dir_input) as nb:\\n\",\n",
    "    \"        nb_dict = json.loads(nb.read())\\n\",\n",
    "    \"    cells: list = nb_dict['cells']\\n\",\n",
    "    \"    cell_rows = []\\n\",\n",
    "    \"    # pprint(cells)\\n\",\n",
    "    \"    for cell in cells:\\n\",\n",
    "    \"        if cell['cell_type'] == 'code':\\n\",\n",
    "    \"            exec_count = cell.get('execution_count', None)\\n\",\n",
    "    \"            exec_count = exec_count if exec_count else ' '\\n\",\n",
    "    \"            cell_rows.append(f\\\"# In[{exec_count}]:\\\\n\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"            for row in cell.get('source', []):\\n\",\n",
    "    \"                cell_rows.append(fixrow(row))\\n\",\n",
    "    \"\\n\",\n",
    "    \"        else:\\n\",\n",
    "    \"            # p(f\\\"appending noncode rows:\\\")\\n\",\n",
    "    \"            # p(cell.get('source', []))\\n\",\n",
    "    \"            for row in cell.get('source', []):\\n\",\n",
    "    \"                cell_rows.append(f\\\"# {fixrow(row)}\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"    with open(dir_output, 'w') as py_out:\\n\",\n",
    "    \"        py_out.write(''.join(cell_rows))\\n\",\n",
    "    \"\\n\",\n",
    "    \"    # TODO use the last parts of the script to build a valid shebang\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def demo(truename=False):\\n\",\n",
    "    \"    py2j('j2py.py', 'j2py_demo.ipynb')\\n\",\n",
    "    \"    j2py('j2py_demo.ipynb', 'j2py_demo.py')\\n\",\n",
    "    \"    for i in range(50):\\n\",\n",
    "    \"        py2j('j2py_demo.py', 'j2py_demo.ipynb')\\n\",\n",
    "    \"        j2py('j2py_demo.ipynb', 'j2py_demo.py')\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def fixrow(s):\\n\",\n",
    "    \"    '''add a newline at the end of a row, if missing'''\\n\",\n",
    "    \"    if s == '' or s is None:\\n\",\n",
    "    \"        return '\\\\n'\\n\",\n",
    "    \"    if s[-1] != '\\\\n':\\n\",\n",
    "    \"        return s + '\\\\n'\\n\",\n",
    "    \"    return s\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def graphicsdemo():\\n\",\n",
    "    \"    ...\\n\",\n",
    "    \"# if True:\\n\",\n",
    "    \"#     import tkinter\\n\",\n",
    "    \"#     from tkinter import ttk\\n\",\n",
    "    \"#     from tkinter.filedialog import askopenfilename\\n\",\n",
    "    \"#     from tkinter.simpledialog import askstring\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"# def windowselect():\\n\",\n",
    "    \"#     # Store the path to the selected file\\n\",\n",
    "    \"#     tkinter.Tk().withdraw()  # Do not show root window\\n\",\n",
    "    \"#     start_folder = Path('.')\\n\",\n",
    "    \"#     startfile = askopenfilename(initialdir=start_folder)\\n\",\n",
    "    \"\\n\",\n",
    "    \"#     if startfile == '':\\n\",\n",
    "    \"#         print('You did not select any file.')\\n\",\n",
    "    \"#         input('Press enter to close...')\\n\",\n",
    "    \"#         # sys.exit()\\n\",\n",
    "    \"#     else:\\n\",\n",
    "    \"#         print('Source selected: ' + startfile)\\n\",\n",
    "    \"#         outputfile = askstring(\\n\",\n",
    "    \"#             \\\"Output file name\\\",\\n\",\n",
    "    \"#             initialvalue=convert_name(startfile))\\n\",\n",
    "    \"#         print(outputfile)\\n\",\n",
    "    \"#         return (startfile, outputfile)\\n\"\n",
    "   ]\n",
    "  },\n",
    "  {\n",
    "   \"cell_type\": \"code\",\n",
    "   \"execution_count\": \"4\",\n",
    "   \"id\": \"h6zghip4-uv9z-n4o0-oafk-w4qaeqpphq5k\",\n",
    "   \"metadata\": {},\n",
    "   \"outputs\": [],\n",
    "   \"source\": [\n",
    "    \"\\n\",\n",
    "    \"\\n\"\n",
    "   ]\n",
    "  },\n",
    "  {\n",
    "   \"cell_type\": \"code\",\n",
    "   \"execution_count\": \"13\",\n",
    "   \"id\": \"4prcem5n-5xc6-c6uc-1ddn-u1jgisdziogi\",\n",
    "   \"metadata\": {},\n",
    "   \"outputs\": [],\n",
    "   \"source\": [\n",
    "    \"def main():\\n\",\n",
    "    \"    print(TITLE)\\n\",\n",
    "    \"    print(\\\"P2J conversion utility\\\")\\n\",\n",
    "    \"    demo()\\n\",\n",
    "    \"    return\\n\",\n",
    "    \"\\n\",\n",
    "    \"    if len(sys.argv) == 1 or re.search(r\\\"ipy(nb|kernel)\\\", sys.argv[0]):\\n\",\n",
    "    \"        print(\\\"Prompt launch\\\")\\n\",\n",
    "    \"        dir_input = input(\\n\",\n",
    "    \"            \\\"Please insert the input file name (must be a .py or .ipynb file) \\\")\\n\",\n",
    "    \"        dir_output = input(\\n\",\n",
    "    \"            f\\\"Please insert the name of the output file ({convert_name(dir_input)} by default) \\\")\\n\",\n",
    "    \"        if dir_output == '':\\n\",\n",
    "    \"            dir_output = convert_name(dir_input)\\n\",\n",
    "    \"    else:\\n\",\n",
    "    \"        dir_input = sys.argv[1]\\n\",\n",
    "    \"        if len(sys.argv) >= 2:\\n\",\n",
    "    \"            dir_output = sys.argv[2]\\n\",\n",
    "    \"        else:\\n\",\n",
    "    \"            dir_output = convert_name(dir_input)\\n\",\n",
    "    \"\\n\",\n",
    "    \"    assert dir_input and dir_output, \\\"Missing input and/or output file names\\\"\\n\",\n",
    "    \"    if dir_input == 'demo':\\n\",\n",
    "    \"        demo(True)\\n\",\n",
    "    \"\\n\",\n",
    "    \"    if '.py' in dir_input and '.ipynb' in dir_output:\\n\",\n",
    "    \"        py2j(dir_input, dir_output)\\n\",\n",
    "    \"    elif '.ipynb' in dir_input and '.py' in dir_output:\\n\",\n",
    "    \"        j2py(dir_input, dir_output)\\n\",\n",
    "    \"\\n\",\n",
    "    \"    p(f\\\"{dir_input}->{dir_output}\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"\\n\",\n",
    "    \"if __name__ == '__main__':\\n\",\n",
    "    \"    main()\\n\"\n",
    "   ]\n",
    "  }\n",
    " ],\n",
    " \"metadata\": {\n",
    "  \"kernelspec\": {\n",
    "   \"display_name\": \"Python 3 (ipykernel)\",\n",
    "   \"language\": \"python\",\n",
    "   \"name\": \"python3\"\n",
    "  },\n",
    "  \"language_info\": {\n",
    "   \"codemirror_mode\": {\n",
    "    \"name\": \"ipython\",\n",
    "    \"version\": 3\n",
    "   },\n",
    "   \"file_extension\": \".py\",\n",
    "   \"mimetype\": \"text/x-python\",\n",
    "   \"name\": \"python\",\n",
    "   \"nbconvert_exporter\": \"python\",\n",
    "   \"pygments_lexer\": \"ipython3\",\n",
    "   \"version\": \"3.9.6\"\n",
    "  }\n",
    " },\n",
    " \"nbformat\": 4,\n",
    " \"nbformat_minor\": 5\n",
    "}"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}